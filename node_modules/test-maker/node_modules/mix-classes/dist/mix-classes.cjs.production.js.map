{"version":3,"file":"mix-classes.cjs.production.js","sources":["../src/getMixin.ts","../src/createMixinClass.ts","../src/Generic.ts","../src/Mix.ts"],"sourcesContent":["import { Constructable } from './types'\r\nimport { INSTANCE_THIS } from './createMixinClass'\r\n\r\n/**\r\n * Gets a specific mixin's `this`\r\n * @param instance The this object to search on\r\n * @param MixinClass The mixin you want to find\r\n */\r\nexport const getMixin = <TConstructable extends Constructable>(\r\n  instance: any,\r\n  MixinClass: TConstructable\r\n): TConstructable['prototype'] | undefined => {\r\n  if (instance && instance[INSTANCE_THIS]) {\r\n    return instance[INSTANCE_THIS].get(MixinClass)\r\n  }\r\n  return undefined\r\n}\r\n","import { getMixin } from './getMixin'\r\nimport { Constructable, Mixable, Mixin } from './types'\r\n\r\nexport const INSTANCE_THIS = Symbol('instanceThis')\r\nexport const MIXIN_CLASSES = Symbol('mixinClasses')\r\n\r\nconst extend = (base: any, extension: any) =>\r\n  new Proxy(base, {\r\n    get: (_, prop) => {\r\n      const target = prop in extension ? extension : base\r\n\r\n      return target[prop]\r\n    },\r\n    set: (_, prop, value) => {\r\n      const target = prop in extension ? extension : base\r\n      target[prop] = value\r\n\r\n      return true\r\n    },\r\n  })\r\n\r\nconst extractConstructable = (Mixable: Mixable): Constructable =>\r\n  'prototype' in Mixable ? Mixable : Mixable.Class\r\n\r\nexport const createMixinClass = <TMixables extends Mixable[]>(\r\n  Mixables: TMixables\r\n) => {\r\n  const Classes = Mixables.map(extractConstructable)\r\n\r\n  const MixinClass = class MixinClass {\r\n    static [MIXIN_CLASSES] = Classes;\r\n\r\n    // Stores the `this` proxies for each class\r\n    [INSTANCE_THIS] = new WeakMap()\r\n\r\n    constructor(...classesArgs: any[]) {\r\n      Classes.forEach((Class, i) => {\r\n        const instance = new Class(...(classesArgs[i] || []))\r\n        const instanceThis = extend(this, instance)\r\n\r\n        this[INSTANCE_THIS].set(Class, instanceThis)\r\n\r\n        // Copy over getters to instance values\r\n        Object.keys(instance).forEach(key => {\r\n          Object.defineProperty(this, key, {\r\n            configurable: true,\r\n            enumerable: true,\r\n            get() {\r\n              return instance[key]\r\n            },\r\n            set(value) {\r\n              return (instance[key] = value)\r\n            },\r\n          })\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  Classes.forEach(Class => {\r\n    const restoreThisInsideFunction = (fn: Function) =>\r\n      function(this: typeof MixinClass['prototype'], ...args: any[]) {\r\n        return fn.apply(getMixin(this, Class), args)\r\n      }\r\n\r\n    // Copy over prototype methods\r\n    const recursePrototype = (prototype: Constructable['prototype']) => {\r\n      // Add instanceof support\r\n      const hasInstance = prototype.constructor[Symbol.hasInstance]\r\n\r\n      Object.defineProperty(prototype.constructor, Symbol.hasInstance, {\r\n        configurable: true,\r\n        value(possibleMixin: typeof MixinClass['prototype']) {\r\n          // Retain original instanceof for prototype\r\n          if (prototype.isPrototypeOf(possibleMixin)) return true\r\n\r\n          if (possibleMixin && possibleMixin.constructor) {\r\n            const isInMixins = (mixin: any): boolean => {\r\n              const classes = mixin[MIXIN_CLASSES]\r\n              if (!classes) return false\r\n              for (const cls of classes) {\r\n                if (cls === Class) return true\r\n                const isChildMixin = isInMixins(cls)\r\n                if (isChildMixin) return true\r\n              }\r\n              return false\r\n            }\r\n\r\n            if (this && this !== prototype.constructor) {\r\n              // not used as mixin, `class [this] extends [prototype.constructor] {}`\r\n\r\n              return prototype.constructor.isPrototypeOf(\r\n                possibleMixin.constructor\r\n              )\r\n            }\r\n\r\n            if (isInMixins(possibleMixin.constructor)) return true\r\n\r\n            if (!this) return false\r\n          }\r\n\r\n          return hasInstance(possibleMixin)\r\n        },\r\n      })\r\n\r\n      Object.getOwnPropertyNames(prototype).forEach(name => {\r\n        if (name === 'constructor') return\r\n\r\n        const descriptor = Object.getOwnPropertyDescriptor(prototype, name)!\r\n\r\n        if (descriptor.get) {\r\n          descriptor.get = restoreThisInsideFunction(descriptor.get)\r\n        }\r\n\r\n        if (descriptor.set) {\r\n          descriptor.set = restoreThisInsideFunction(descriptor.set)\r\n        }\r\n\r\n        if (typeof descriptor.value === 'function') {\r\n          descriptor.value = restoreThisInsideFunction(descriptor.value)\r\n        }\r\n\r\n        if (!MixinClass.prototype.hasOwnProperty(name)) {\r\n          Object.defineProperty(MixinClass.prototype, name, descriptor)\r\n        }\r\n      })\r\n\r\n      const parent = Object.getPrototypeOf(prototype)\r\n      if (parent && parent !== Object.prototype) recursePrototype(parent)\r\n    }\r\n\r\n    recursePrototype(Class.prototype)\r\n  })\r\n\r\n  return (MixinClass as any) as Mixin<TMixables>\r\n}\r\n","import { Constructable } from './types'\r\n\r\nexport type IGeneric<TConstructable extends Constructable = any> = {\r\n  Class: TConstructable\r\n}\r\n\r\nexport const Generic = <TConstructable extends Constructable>(\r\n  Class: TConstructable\r\n): IGeneric<TConstructable> => ({\r\n  Class,\r\n})\r\n","import { Mixable } from './types'\r\nimport { createMixinClass } from './createMixinClass'\r\n\r\nexport const Mix = <TMixables extends Mixable[]>(...Mixables: TMixables) =>\r\n  createMixinClass(Mixables)\r\n"],"names":["getMixin","instance","MixinClass","INSTANCE_THIS","get","Symbol","MIXIN_CLASSES","extractConstructable","Mixable","Class","Mixables","Classes","map","classesArgs","WeakMap","forEach","i","base","extension","instanceThis","_this","Proxy","_","prop","set","value","Object","keys","key","defineProperty","configurable","enumerable","_c","restoreThisInsideFunction","fn","args","apply","this","recursePrototype","prototype","hasInstance","constructor","possibleMixin","isPrototypeOf","isInMixins","mixin","classes","getOwnPropertyNames","name","descriptor","getOwnPropertyDescriptor","hasOwnProperty","parent","getPrototypeOf","createMixinClass"],"mappings":"uhBAQA,IAAaA,EAAW,SACtBC,EACAC,MAEID,GAAYA,EAASE,UAChBF,EAASE,GAAeC,IAAIF,ICV1BC,EAAgBE,OAAO,gBACvBC,EAAgBD,OAAO,gBAiB9BE,EAAuB,SAACC,SAC5B,cAAeA,EAAUA,EAAUA,EAAQC,uBChBtB,SACrBA,SAC8B,CAC9BA,MAAAA,gBCNiB,sCAAiCC,2BAAAA,yBFqBpB,SAC9BA,WAEMC,EAAUD,EAASE,IAAIL,GAEvBL,KAMJ,6CAAeW,2BAAAA,0BAFG,IAAIC,QAGpBH,EAAQI,QAAQ,SAACN,EAAOO,OA9BdC,EAAWC,EA+BbjB,IAAeQ,EAAUI,EAAYG,IAAM,IAC3CG,GAhCEF,EAgCoBG,EAhCTF,EAgCejB,EA/BxC,IAAIoB,MAAMJ,EAAM,CACdb,IAAK,SAACkB,EAAGC,UACQA,KAAQL,EAAYA,EAAYD,GAEjCM,IAEhBC,IAAK,SAACF,EAAGC,EAAME,UACEF,KAAQL,EAAYA,EAAYD,GACxCM,GAAQE,GAER,MAuBLL,EAAKjB,GAAeqB,IAAIf,EAAOU,GAG/BO,OAAOC,KAAK1B,GAAUc,QAAQ,SAAAa,GAC5BF,OAAOG,eAAeT,EAAMQ,EAAK,CAC/BE,cAAc,EACdC,YAAY,EACZ3B,sBACSH,EAAS2B,IAElBJ,aAAIC,UACMxB,EAAS2B,GAAOH,YAlBjCtB,EAHM6B,EAAC1B,GAAiBK,YA6B3BA,EAAQI,QAAQ,SAAAN,OACRwB,EAA4B,SAACC,UACjC,sCAAkDC,2BAAAA,yBACzCD,EAAGE,MAAMpC,EAASqC,KAAM5B,GAAQ0B,MAIlB,SAAnBG,EAAoBC,OAElBC,EAAcD,EAAUE,YAAYpC,OAAOmC,aAEjDd,OAAOG,eAAeU,EAAUE,YAAapC,OAAOmC,YAAa,CAC/DV,cAAc,EACdL,eAAMiB,MAEAH,EAAUI,cAAcD,GAAgB,OAAO,KAE/CA,GAAiBA,EAAcD,YAAa,IAY1CJ,MAAQA,OAASE,EAAUE,mBAGtBF,EAAUE,YAAYE,cAC3BD,EAAcD,gBAfC,SAAbG,EAAcC,OACZC,EAAUD,EAAMvC,OACjBwC,EAAS,OAAO,QACHA,0DAAS,4FACbrC,EAAO,OAAO,KACLmC,KACH,OAAO,SAEpB,EAWLA,CAAWF,EAAcD,aAAc,OAAO,MAE7CJ,KAAM,OAAO,SAGbG,EAAYE,MAIvBhB,OAAOqB,oBAAoBR,GAAWxB,QAAQ,SAAAiC,MAC/B,gBAATA,OAEEC,EAAavB,OAAOwB,yBAAyBX,EAAWS,GAE1DC,EAAW7C,MACb6C,EAAW7C,IAAM6B,EAA0BgB,EAAW7C,MAGpD6C,EAAWzB,MACbyB,EAAWzB,IAAMS,EAA0BgB,EAAWzB,MAGxB,mBAArByB,EAAWxB,QACpBwB,EAAWxB,MAAQQ,EAA0BgB,EAAWxB,QAGrDvB,EAAWqC,UAAUY,eAAeH,IACvCtB,OAAOG,eAAe3B,EAAWqC,UAAWS,EAAMC,UAIhDG,EAAS1B,OAAO2B,eAAed,GACjCa,GAAUA,IAAW1B,OAAOa,WAAWD,EAAiBc,GAG9Dd,CAAiB7B,EAAM8B,aAGjBrC,EElIRoD,CAAiB5C"}