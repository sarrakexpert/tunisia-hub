/// <reference types="node" />
import { ParsedMail } from 'mailparser';
import { TestAccount } from 'nodemailer';
import SMTPTransport from 'nodemailer/lib/smtp-transport';
import type { Controller } from '../..';
import { HttpClientResponse } from '../..';
import { DataFaker, DataFakerOptions } from '../../helpers/fake';
import { JsonPdf } from '../../helpers/json-pdf';
import type { ClientInfo } from '../../types/client/client-info';
import { Configuration } from '../../types/configuration/configuration';
import type { DeepPartial } from '../../types/deep-partial';
import type { Session } from '../../types/session-phase-run-info/session';
import { ActionabilityCheckTypes } from '../../types/test-api/actionability-check-types';
import type { AssertOptions } from '../../types/test-api/assertion/assert-options';
import type { Matchers } from '../../types/test-api/assertion/matchers';
import type { SelectorMatchers } from '../../types/test-api/assertion/selector-matchers';
import { AttachmentTypes } from '../../types/test-api/attachment-types';
import type { ClientFunctionArgs } from '../../types/test-api/client-function/client-function-args';
import { AddImageReporterAttachmentOptions } from '../../types/test-api/controller/add-image-reporter-attachment-options';
import { AddTextReporterAttachmentOptions } from '../../types/test-api/controller/add-text-reporter-attachment-options';
import { BenchmarkOptions } from '../../types/test-api/controller/benchmark-options';
import { BenchmarkResult } from '../../types/test-api/controller/benchmark-result';
import type { ClientLogs } from '../../types/test-api/controller/client-logs';
import { Cookie } from '../../types/test-api/controller/cookie';
import type { DragToSelectorOptions } from '../../types/test-api/controller/drag-to-selector-options';
import { EvalInAllFramesOptions } from '../../types/test-api/controller/eval-in-all-frames-options';
import type { FillActionOptions } from '../../types/test-api/controller/fill-action-options';
import { HandleDialogOptions } from '../../types/test-api/controller/handle-dialog-options';
import { HandleRouteParams } from '../../types/test-api/controller/handle-route-params';
import type { HttpRequestConfig } from '../../types/test-api/controller/http-request-config';
import type { KeyModifiers } from '../../types/test-api/controller/key-modifiers';
import { NetworkCondition } from '../../types/test-api/controller/network-condition';
import { NetworkConditionPreset } from '../../types/test-api/controller/network-condition-preset';
import { ParseMailParameters } from '../../types/test-api/controller/parse-mail-parameters';
import { RecordVideoOptions } from '../../types/test-api/controller/record-video-options';
import { SendMailOptions } from '../../types/test-api/controller/send-mail-options';
import { WaitForVisualStateOptions } from '../../types/test-api/controller/wait-for-visual-state-options';
import { WaitForVisualStateResult } from '../../types/test-api/controller/wait-for-visual-state-reuslt';
import { WaitFrameToLodOptions } from '../../types/test-api/controller/wait-frame-to-lod-options';
import { Selector } from '../../types/test-api/selector/selector';
import { selectorType } from '../../types/test-api/selector/selector-type';
import type { WaitForConditionOptions } from '../../types/waitForConditionOptions';
export declare class ControllerProxy {
    session: Session;
    ctx: {
        [key: string]: any;
    };
    currentFrame: string;
    currentFrameSelector: any;
    pendingError: Error | undefined;
    actions: (() => any)[];
    readonly t: Controller;
    firstNavigationHappened: boolean;
    private cachedInjections;
    private httpClient;
    private customActions;
    private extraHudInfo;
    constructor(session: Session);
    fillField(selector: any, text: string | number, options?: FillActionOptions): Promise<void>;
    appendField(selector: any, text: string | number, options?: FillActionOptions): Promise<void>;
    prependField(selector: any, text: string | number, options?: FillActionOptions): Promise<void>;
    clearField(selector: any): Promise<void>;
    select(selector: any): Promise<void>;
    selectOption(selector: any, option: string | number | {
        label?: string;
        value?: string;
        index?: number;
    } | string[] | number[] | {
        label?: string;
        value?: string;
        index?: number;
    }[]): Promise<void>;
    deselectOption(selector: any, option: string | number | {
        label?: string;
        value?: string;
        index?: number;
    } | string[] | number[] | {
        label?: string;
        value?: string;
        index?: number;
    }[]): Promise<void>;
    checkOption(selector: any): Promise<void>;
    uncheckOption(selector: any): Promise<void>;
    pressKey(keys: string): Promise<void>;
    pressUpKey(keys: string): Promise<void>;
    pressDownKey(keys: string): Promise<void>;
    pressEnterKey(): Promise<void>;
    pressTabKey(): Promise<void>;
    pressArrowUpKey(): Promise<void>;
    pressArrowDownKey(): Promise<void>;
    pressArrowLeftKey(): Promise<void>;
    pressArrowRightKey(): Promise<void>;
    focus(selector: any): Promise<void>;
    blur(selector: any): Promise<void>;
    click(selector: any, options?: {
        modifiers?: KeyModifiers;
    }): Promise<void>;
    doubleClick(selector: any, options?: {
        modifiers?: KeyModifiers;
    }): Promise<void>;
    middleClick(selector: any, options?: {
        modifiers?: KeyModifiers;
    }): Promise<void>;
    rightClick(selector: any, options?: {
        modifiers?: KeyModifiers;
    }): Promise<void>;
    hover(selector: any, options?: {
        modifiers?: KeyModifiers;
    }): Promise<void>;
    mouseUp(options?: {
        x?: number;
        y?: number;
        button: `left` | `middle` | `right`;
        modifiers?: KeyModifiers;
    }): Promise<void>;
    mouseDown(options?: {
        x?: number;
        y?: number;
        button: `left` | `middle` | `right`;
        modifiers?: KeyModifiers;
    }): Promise<void>;
    mouseMove(x: number, y: number, options?: {
        modifiers?: KeyModifiers;
    }): Promise<void>;
    drag(selector: any, dragOffsetX: number, dragOffsetY: number, options?: DragToSelectorOptions): Promise<void>;
    dragToSelector(selector: any, destinationSelector: any, options?: DragToSelectorOptions): Promise<void>;
    moveCursorToSelector(selector: any, offsetX: number, offsetY: number): Promise<void>;
    selectText(selector: any, startPos?: number, endPos?: number): Promise<void>;
    selectContent(selector: any): Promise<void>;
    selectEditableContent(startSelector: any, endSelector: any): Promise<void>;
    selectTextAreaContent({ selector, startLine, startPosition, endLine, endPosition }: {
        selector: any;
        startLine?: number;
        startPosition?: number;
        endLine?: number;
        endPosition?: number;
    }): Promise<void>;
    upload({ filesSelector, submitSelector, delayBeforeSubmit, filePath }: {
        filesSelector: any;
        submitSelector: any;
        delayBeforeSubmit?: number;
        filePath?: string | string[];
    }): Promise<void>;
    setFilesToUpload(selector: any, filePath: string | string[]): Promise<void>;
    clearUpload(selector: any): Promise<void>;
    scrollToTop(): Promise<void>;
    scrollToBottom(): Promise<void>;
    scrollToSelector(selector: any, offsetX?: number, offsetY?: number): Promise<void>;
    scrollTo(offsetX: number, offsetY: number): Promise<void>;
    goto(url: string): Promise<void>;
    refresh(): Promise<void>;
    goForward(): Promise<void>;
    goBackward(): Promise<void>;
    go(delta: number): Promise<void>;
    maximizeWindow(): Promise<void>;
    resizeWindow(width: number, height: number): Promise<void>;
    switchToFrame(selector: any): Promise<void>;
    switchToMainFrame(): Promise<void>;
    switchToWindow(window: {
        id: string;
    }): Promise<void>;
    switchToParentWindow(): Promise<void>;
    switchToPreviousWindow(window: {
        id: string;
    }): Promise<void>;
    openWindow(url: string): Promise<{
        id: string;
    }>;
    closeWindow(window: {
        id: string;
    }): Promise<void>;
    getCurrentWindow(): Promise<{
        id: string;
    }>;
    handleAlertDialog(fn?: ((text?: string, url?: string) => void) | null, options?: HandleDialogOptions): Promise<void>;
    handleConfirmDialog(fn?: ((text?: string, url?: string) => boolean) | null, options?: HandleDialogOptions): Promise<void>;
    handlePromptDialog(fn?: ((text?: string, url?: string) => string) | null, options?: HandleDialogOptions): Promise<void>;
    handleBeforeunloadDialog(fn?: ((text?: string, url?: string) => boolean) | null, options?: HandleDialogOptions): Promise<void>;
    handleNativeDialog(fn: ((type: 'alert' | 'confirm' | 'beforeunload' | 'prompt', text?: string, url?: string) => any) | null, options?: HandleDialogOptions): Promise<void>;
    setCookie(cookie: {
        name: string;
        value: string;
        domain?: string;
        path?: string;
        expires?: Date;
        secure?: boolean;
        sameSite?: `Lax` | `Strict` | `None`;
    }): Promise<void>;
    getCookie(cookieName: string): Promise<Cookie | null>;
    clearCookie(cookieName: string): Promise<void>;
    deleteCookie(cookieName: string): Promise<void>;
    setLocalStorage(name: string, value: string): Promise<void>;
    getLocalStorage(name: string): Promise<string | null>;
    removeLocalStorage(name: string): Promise<void>;
    setSessionStorage(name: string, value: string): Promise<void>;
    getSessionStorage(name: string): Promise<string | null>;
    removeSessionStorage(name: string): Promise<void>;
    injectCss({ compile, code, filePath, name, position }: {
        compile?: boolean;
        code?: string;
        filePath?: string;
        name: string;
        position?: 'head' | 'bodyTop' | 'bodyBottom';
    }): Promise<void>;
    injectJs({ compile, code, filePath, name, position }: {
        compile?: boolean;
        code?: string;
        filePath?: string;
        name?: string;
        position?: `head` | `bodyTop` | `bodyBottom`;
    }): Promise<void>;
    sendGetRequest<T = any, R = HttpClientResponse<T>>(url: string, config?: HttpRequestConfig): Promise<R>;
    sendDeleteRequest<T = any, R = HttpClientResponse<T>>(url: string, config?: HttpRequestConfig): Promise<R>;
    sendHeadRequest<T = any, R = HttpClientResponse<T>>(url: string, config?: HttpRequestConfig): Promise<R>;
    sendPostRequest<T = any, R = HttpClientResponse<T>>(url: string, data: Record<string, any>, config?: HttpRequestConfig): Promise<R>;
    sendPutRequest<T = any, R = HttpClientResponse<T>>(url: string, data: Record<string, any>, config?: HttpRequestConfig): Promise<R>;
    sendPatchRequest<T = any, R = HttpClientResponse<T>>(url: string, data: Record<string, any>, config?: HttpRequestConfig): Promise<R>;
    handleRoute({ url, handler }: HandleRouteParams): Promise<void>;
    sendMail({ mailOptions, transport, transportDefaults }: SendMailOptions): Promise<SMTPTransport.SentMessageInfo>;
    parseMail({ source, options }: ParseMailParameters): Promise<ParsedMail>;
    createTestMailAccount(apiUrl: string | undefined): Promise<TestAccount>;
    parsePDF(filPath: string): Promise<JsonPdf>;
    triggerClientEvent(eventName: string, data: {
        [key: string]: any;
    }): Promise<void>;
    handleClientEvent(eventName: string, fn: (data: {
        [key: string]: any;
    }) => Promise<void>): Promise<void>;
    handleServerEvent(eventName: string, fn: (data: {
        [key: string]: any;
    }) => Promise<void>): Promise<void>;
    triggerServerEvent(eventName: string, data: {
        [key: string]: any;
    }): Promise<void>;
    eval<Arg, R>(fn: (arg: ClientFunctionArgs<Arg>) => R | Promise<R>, arg?: ClientFunctionArgs<Arg>): Promise<R>;
    evalInMainWindowMainFrame<Arg, R>(fn: (arg: ClientFunctionArgs<Arg>) => R | Promise<R>, arg?: ClientFunctionArgs<Arg>): Promise<R>;
    evalInCurrentWindowMainFrame<Arg, R>(fn: (arg: ClientFunctionArgs<Arg>) => R | Promise<R>, arg?: ClientFunctionArgs<Arg>): Promise<R>;
    evalInAllFrames<Arg, R>(options: EvalInAllFramesOptions): Promise<any>[];
    getClientInfo(): Promise<ClientInfo>;
    wait(timeout: number): Promise<void>;
    waitForCondition(options: WaitForConditionOptions): Promise<void>;
    waitForSelectorToExist(selector: any): Promise<void>;
    waitForSelectorToNotExist(selector: any): Promise<void>;
    waitForSelectorToBeVisible(selector: any): Promise<void>;
    waitForSelectorToBeInvisible(selector: any): Promise<void>;
    waitForSelectActionabilityCheck(selector: any, checks: ActionabilityCheckTypes[]): Promise<void>;
    waitForFrameToLoad(selector: any, options: WaitFrameToLodOptions): Promise<void>;
    waitForVisualState(options: WaitForVisualStateOptions): Promise<WaitForVisualStateResult>;
    expect(actual: any, options?: AssertOptions): Matchers;
    expectSelector(actual: any, options?: AssertOptions): SelectorMatchers;
    fake(options: DataFakerOptions): DataFaker;
    debugger(): Promise<void>;
    getClientLogs(): Promise<ClientLogs>;
    takeScreenshot(filePath: string, options?: {
        fullPage: boolean;
    }): Promise<void>;
    takeSelectorScreenshot(selector: selectorType, filePath: string): Promise<void>;
    recordVideo(options: RecordVideoOptions): Promise<{
        id: string;
        pause: () => Promise<void>;
        resume: () => Promise<void>;
        stop: () => Promise<void>;
    }>;
    startTracing({ path }: {
        path: string;
    }): Promise<void>;
    stopTracing(): Promise<void>;
    emulateNetworkConditions(condition: NetworkConditionPreset | NetworkCondition): Promise<void>;
    getScrollPosition(): Promise<{
        left: number;
        top: number;
    }>;
    getTitle(): Promise<string>;
    getCurrentUrl(): Promise<string>;
    getSource(): Promise<string>;
    benchmark({ name, functions, options }: {
        name: string;
        functions: {
            name: string;
            fn: () => Promise<void>;
        }[];
        options?: BenchmarkOptions;
    }): Promise<BenchmarkResult>;
    addReporterAttachment({ name, content, path, mimeType }: {
        name?: string;
        content: Buffer | string;
        path?: string;
        mimeType: AttachmentTypes;
    }): Promise<void>;
    addScreenshotReporterAttachment({ title, filePath }: AddImageReporterAttachmentOptions): Promise<void>;
    addImageReporterAttachment({ title, filePath }: AddImageReporterAttachmentOptions): Promise<void>;
    addTextReporterAttachment({ title, content }: AddTextReporterAttachmentOptions): Promise<void>;
    addHtmlReporterAttachment({ title, content }: AddTextReporterAttachmentOptions): Promise<void>;
    cut(params?: {
        value?: string;
        selector?: any;
        format?: 'text/plain' | 'text/html' | 'default';
        store?: {
            value: string;
        };
    }): Promise<void>;
    copy(params?: {
        value?: string;
        selector?: any;
        format?: 'text/plain' | 'text/html' | 'default';
        store?: {
            value: string;
        };
    }): Promise<void>;
    paste(to: any, store?: {
        value: string;
    }): Promise<void>;
    getSpecStates({ feature, scenario, step, subStep }: {
        feature: {
            name: string;
        };
        scenario: {
            name: string;
            keyword: string;
        };
        step: {
            name: string;
            keyword: string;
        };
        subStep?: {
            name: string;
        };
    }): Promise<void>;
    launchApp({ id, path, type, args }: {
        id: string;
        path: string;
        type?: string;
        args?: any[];
    }): Promise<void>;
    closeApp(id: string): Promise<void>;
    switchToApp(id: string): Promise<void>;
    switchContext(context: string): Promise<void>;
    getContext(): Promise<string | null>;
    getContexts(): Promise<(string | null)[]>;
    getOrientation(): Promise<string>;
    setOrientation(orientation: `LANDSCAPE` | `PORTRAIT`): Promise<void>;
    getGeoLocation(): Promise<{
        latitude: number;
        longitude: number;
        altitude: number;
    }>;
    setGeoLocation(location: {
        latitude: number;
        longitude: number;
        altitude: number;
    }): Promise<void>;
    updateConfiguration(updatedConfiguration: DeepPartial<Configuration>): Promise<void>;
    restoreConfiguration(): Promise<void>;
    updateInfoHud(extraInfo?: string): Promise<void>;
    enableInfoHud(): Promise<void>;
    disableInfoHud(): Promise<void>;
    updateInfoHudInternal(params?: {
        extraInfo?: string;
        debuggerActive?: boolean;
    }): Promise<void>;
    then<TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): PromiseLike<TResult1 | TResult2>;
    private executeActions;
    private stringifyValue;
    private isIe;
    private normalizeSelector;
    private clientInjector;
    private injectDefaultAssets;
    private addCustomActions;
    private validateTimeOut;
    private offsetRetryTimeOut;
    private offsetSelectorTimeOut;
    performActionabilityCheck(selector: any, checks: ActionabilityCheckTypes[]): Promise<Selector>;
}
