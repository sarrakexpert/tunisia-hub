import { Session } from '../../types/session-phase-run-info/session';
import { ActionabilityCheckTypes } from '../../types/test-api/actionability-check-types';
import type { TextRectangle } from '../../types/test-api/controller/text-rectangles';
import type { Selector } from '../../types/test-api/selector/selector';
import type { SelectorOptions } from '../../types/test-api/selector/selector-options';
import { SelectorErrorFormatter } from './selector-error-formatter';
export declare class SelectorProxy {
    session: Session;
    lastError: Error | undefined;
    retryingCount: number;
    retrying: boolean;
    externalRetrying: boolean;
    selector: Selector;
    init: string | (() => Promise<string | SelectorProxy>) | SelectorProxy;
    passedInit: string | (() => Promise<string | SelectorProxy>) | SelectorProxy;
    options: SelectorOptions;
    passedOptions: SelectorOptions | undefined;
    actions: {
        name: string;
        args: any[];
        executed: boolean;
        returnValue: boolean;
        fn: (() => any);
    }[];
    controllerActions: (() => any)[];
    lastFailedAction: string;
    hasControllerActions: boolean;
    overrideTimeout: number;
    formatter: SelectorErrorFormatter;
    keepActionsOnResolve: boolean;
    private stack;
    private customActions;
    constructor({ init, options }: {
        init: string | SelectorProxy;
        options?: SelectorOptions;
    });
    get id(): Promise<string>;
    get tagName(): Promise<string>;
    get nodeType(): Promise<number>;
    get namespaceURI(): Promise<string | null>;
    get className(): Promise<string>;
    get classNames(): Promise<string[]>;
    get focused(): Promise<boolean>;
    get visible(): Promise<boolean>;
    get clickable(): Promise<boolean>;
    get editable(): Promise<boolean>;
    get attached(): Promise<boolean>;
    get stable(): Promise<boolean>;
    get inViewport(): Promise<boolean>;
    get inViewportPartially(): Promise<boolean>;
    get enabled(): Promise<boolean>;
    get disabled(): Promise<boolean>;
    get exists(): Promise<boolean>;
    get count(): Promise<number>;
    get checked(): Promise<boolean | undefined>;
    get selected(): Promise<boolean | undefined>;
    get selectedIndex(): Promise<number | undefined>;
    get value(): Promise<string | undefined>;
    get nodeValue(): Promise<string | null>;
    get textContent(): Promise<string>;
    get innerText(): Promise<string>;
    get innerHTML(): Promise<string>;
    get outerHTML(): Promise<string>;
    get style(): Promise<{
        [prop: string]: string;
    }>;
    get childElementCount(): Promise<number>;
    get childNodeCount(): Promise<number>;
    get hasChildElements(): Promise<boolean>;
    get hasChildNodes(): Promise<boolean>;
    get attributes(): Promise<{
        [name: string]: string;
    }>;
    get clientHeight(): Promise<number>;
    get clientLeft(): Promise<number>;
    get clientTop(): Promise<number>;
    get clientWidth(): Promise<number>;
    get offsetHeight(): Promise<number>;
    get offsetLeft(): Promise<number>;
    get offsetTop(): Promise<number>;
    get offsetWidth(): Promise<number>;
    get scrollHeight(): Promise<number>;
    get scrollLeft(): Promise<number>;
    get scrollTop(): Promise<number>;
    get scrollWidth(): Promise<number>;
    get boundingClientRect(): Promise<TextRectangle>;
    hasClass(className: string): Promise<boolean>;
    hasAttribute(attributeName: string): Promise<boolean>;
    getAttribute(attributeName: string): Promise<string>;
    getStyleProperty(propertyName: string): Promise<string>;
    getBoundingClientRectProperty(propertyName: string): Promise<number>;
    nth(index: number): Selector;
    withText(text: string | RegExp): Selector;
    withExactText(text: string): Selector;
    withAttribute(attrName: string | RegExp, attrValue?: string | RegExp): Selector;
    filter(...args: any[]): Selector;
    filterVisible(): Selector;
    filterHidden(): Selector;
    find(...args: any[]): Selector;
    parent(...args: any[]): Selector;
    child(...args: any[]): Selector;
    sibling(...args: any[]): Selector;
    nextSibling(...args: any[]): Selector;
    prevSibling(...args: any[]): Selector;
    all(): Promise<Selector[]>;
    clone(cloneActions?: boolean): Selector;
    with(options?: SelectorOptions): this;
    then<TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): PromiseLike<TResult1 | TResult2>;
    resolveSelector(): Promise<void>;
    executeActions({ actionability }: {
        actionability?: ActionabilityCheckTypes[];
    }): Promise<any>;
    private queueAction;
    private setOptions;
    private validateTimeout;
    private runActions;
    assertElementIsReady(): Promise<boolean>;
    actionabilityCheck(checks?: ActionabilityCheckTypes[]): Promise<void>;
    private cleanUp;
    private addCustomActions;
}
