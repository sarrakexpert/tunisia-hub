import { SubStep } from "../../gherkin/functions";
import { TestPhase } from "../../gherkin/functions/testPhase";
import { FeatureSpec, ScenarioSpec, StepSpec } from "../../specs";
import { BaseSpec } from "../../specs/base-spec";
import { AdapterApi } from "../adapter/adapter-api";
import { AdapterUsedClient } from "../adapter/adapter-used-client";
import { ClientInstance } from "../adapter/client-instance";
import { TestMakerAdapter } from "../adapter/testMakerAdapter";
import { ClientInfo } from "../client/client-info";
import { ClientFunction } from "../test-api/client-function/client-function";
import { Controller } from "../test-api/controller/controller";
import { Selector } from "../test-api/selector/selector";
import { PhaseContext } from "./phase-context";
import { TestRunInfo } from "./test-run-info";
export interface Session {
    id: string;
    uid: string;
    runId: string;
    done: boolean;
    clientInstance: ClientInstance;
    startTime: Date;
    endTime: Date;
    timeout: number;
    spec: FeatureSpec;
    sourcePath: string;
    distPath: string;
    isCancelled: boolean;
    errorPhase?: TestPhase;
    appIsBusy: boolean;
    appIsBusyError: Error | undefined;
    checkingIfAppIsBusy: boolean;
    currentPhase: TestPhase;
    currentPhaseContext: PhaseContext;
    currentFeatureSpec: FeatureSpec;
    currentScenarioSpec?: ScenarioSpec;
    currentStepSpec?: StepSpec;
    currentAction?: string;
    currentSpec: BaseSpec;
    skipNextScenarioOnFail: boolean;
    skipNextStepOnFail: boolean;
    subSteps: Map<string, SubStep>;
    adapter: TestMakerAdapter;
    adapterApi: AdapterApi;
    client: ClientInfo;
    usedClient: AdapterUsedClient;
    controller: Controller;
    selector: Selector;
    clientFunction: ClientFunction;
    testRunInfo: TestRunInfo;
    socket: any;
    socketEvents: {
        [key: string]: (data: {
            [key: string]: any;
        }) => Promise<void>;
    };
    pendingError: Error | undefined;
    handlePendingError(handleAppIsBusyError?: boolean): void;
    continueDebugging(): void;
    throwError(error: Error): void;
}
