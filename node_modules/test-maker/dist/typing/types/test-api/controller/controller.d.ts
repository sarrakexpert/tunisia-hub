/// <reference types="node" />
import { Promise } from 'es6-promise';
import { TestAccount } from 'nodemailer';
import SMTPTransport from 'nodemailer/lib/smtp-transport';
import { DataFaker, DataFakerOptions } from '../../../helpers/fake';
import { JsonPdf } from '../../../helpers/json-pdf';
import { ClientInfo } from '../../client/client-info';
import { Configuration } from '../../configuration/configuration';
import { DeepPartial } from '../../deep-partial';
import { WaitForConditionOptions } from '../../waitForConditionOptions';
import { ActionabilityCheckTypes } from '../actionability-check-types';
import { AssertOptions } from '../assertion/assert-options';
import { Matchers } from '../assertion/matchers';
import { SelectorMatchers } from '../assertion/selector-matchers';
import { AttachmentTypes } from '../attachment-types';
import { ClientFunctionArgs } from '../client-function/client-function-args';
import { selectorType } from '../selector/selector-type';
import { AddImageReporterAttachmentOptions } from './add-image-reporter-attachment-options';
import { AddTextReporterAttachmentOptions } from './add-text-reporter-attachment-options';
import { BenchmarkOptions } from './benchmark-options';
import { BenchmarkResult } from './benchmark-result';
import { ClientLogs } from './client-logs';
import { ControllerPromise } from './controller-promise';
import { Cookie } from './cookie';
import { DragToSelectorOptions } from './drag-to-selector-options';
import { EvalInAllFramesOptions } from './eval-in-all-frames-options';
import { FillActionOptions } from './fill-action-options';
import { HandleDialogOptions } from './handle-dialog-options';
import { HandleRouteParams } from './handle-route-params';
import { HttpClientResponse } from './http-client-response';
import { HttpRequestConfig } from './http-request-config';
import { KeyModifiers } from './key-modifiers';
import { NetworkCondition } from './network-condition';
import { NetworkConditionPreset } from './network-condition-preset';
import { ParseMailParameters } from './parse-mail-parameters';
import { ParsedMail } from './parsed-mail';
import { RecordVideoOptions } from './record-video-options';
import { SendMailOptions } from './send-mail-options';
import { WaitForVisualStateOptions } from './wait-for-visual-state-options';
import { WaitForVisualStateResult } from './wait-for-visual-state-reuslt';
import { WaitFrameToLodOptions } from './wait-frame-to-lod-options';
interface GenericActions {
    focus(selector: selectorType): ControllerPromise;
    blur(selector: selectorType): ControllerPromise;
}
interface ControllerFormActions {
    fillField(selector: selectorType, text: string | number, options?: Omit<FillActionOptions, 'replace'>): ControllerPromise;
    appendField(selector: selectorType, text: string | number, options?: FillActionOptions): ControllerPromise;
    prependField(selector: selectorType, text: string | number, options?: FillActionOptions): ControllerPromise;
    clearField(selector: selectorType): ControllerPromise;
    select(selector: selectorType): ControllerPromise;
    selectOption(selector: selectorType, option: string | number | {
        label?: string;
        value?: string;
        index?: number;
    } | string[] | number[] | {
        label?: string;
        value?: string;
        index?: number;
    }[]): ControllerPromise;
    deselectOption(selector: selectorType, option: string | number | {
        label?: string;
        value?: string;
        index?: number;
    } | string[] | number[] | {
        label?: string;
        value?: string;
        index?: number;
    }[]): ControllerPromise;
    checkOption(selector: selectorType): ControllerPromise;
    uncheckOption(selector: selectorType): ControllerPromise;
}
interface ControllerButtonActions {
    pressKey(keys: string): ControllerPromise;
    pressUpKey(keys: string): ControllerPromise;
    pressDownKey(keys: string): ControllerPromise;
    pressEnterKey(): ControllerPromise;
    pressTabKey(): ControllerPromise;
    pressArrowUpKey(): ControllerPromise;
    pressArrowDownKey(): ControllerPromise;
    pressArrowLeftKey(): ControllerPromise;
    pressArrowRightKey(): ControllerPromise;
}
interface ControllerMouseActions {
    click(selector: selectorType, options?: {
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    doubleClick(selector: selectorType, options?: {
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    middleClick(selector: selectorType, options?: {
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    rightClick(selector: selectorType, options?: {
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    hover(selector: selectorType, options?: {
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    mouseUp(options?: {
        button: `left` | `middle` | `right`;
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    mouseDown(options?: {
        x?: number;
        y?: number;
        button: `left` | `middle` | `right`;
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    mouseMove(x: number, y: number, options?: {
        modifiers?: KeyModifiers;
    }): ControllerPromise;
    drag(selector: selectorType, dragOffsetX: number, dragOffsetY: number, options?: DragToSelectorOptions): ControllerPromise;
    dragToSelector(selector: selectorType, destinationSelector: selectorType, options?: DragToSelectorOptions): ControllerPromise;
    moveCursorToSelector(selector: selectorType, offsetX?: number, offsetY?: number): ControllerPromise;
}
interface ControllerTextActions {
    selectText(selector: selectorType, startPos?: number, endPos?: number): ControllerPromise;
    selectContent(selector: selectorType): ControllerPromise;
    selectEditableContent(startSelector: selectorType, endSelector: selectorType): ControllerPromise;
    selectTextAreaContent({ selector, startLine, startPosition, endLine, endPosition }: {
        selector: any;
        startLine?: number;
        startPosition?: number;
        endLine?: number;
        endPosition?: number;
    }): ControllerPromise;
}
interface ControllerFileActions {
    upload({ filesSelector, submitSelector, delayBeforeSubmit, filePath }: {
        filesSelector: any;
        submitSelector: any;
        delayBeforeSubmit?: number;
        filePath?: string | string[];
    }): ControllerPromise;
    setFilesToUpload(selector: selectorType, filePath: string | string[]): ControllerPromise;
    clearUpload(selector: selectorType): ControllerPromise;
}
interface ControllerScrollActions {
    scrollToTop(): ControllerPromise;
    scrollToBottom(): ControllerPromise;
    scrollToSelector(selector: selectorType, offsetX?: number, offsetY?: number): ControllerPromise;
    scrollTo(offsetX: number, offsetY: number): ControllerPromise;
}
interface ControllerBrowserActions {
    goto(url: string): ControllerPromise;
    goForward(): ControllerPromise;
    goBackward(): ControllerPromise;
    go(delta: number): ControllerPromise;
    refresh(): ControllerPromise;
    maximizeWindow(): ControllerPromise;
    resizeWindow(width: number, height: number): ControllerPromise;
    switchToFrame(selector: selectorType): ControllerPromise;
    switchToMainFrame(): ControllerPromise;
    switchToWindow(window: {
        id: string;
    }): ControllerPromise;
    switchToParentWindow(): ControllerPromise;
    switchToPreviousWindow(): ControllerPromise;
    openWindow(url: string): Promise<{
        id: string;
    }>;
    closeWindow(window: {
        id: string;
    }): ControllerPromise;
    getCurrentWindow(): Promise<{
        id: string;
    }>;
    handleAlertDialog(fn?: ((text?: string, url?: string) => void) | null, options?: HandleDialogOptions): ControllerPromise;
    handleConfirmDialog(fn?: ((text?: string, url?: string) => boolean) | null, options?: HandleDialogOptions): ControllerPromise;
    handlePromptDialog(fn?: ((text?: string, url?: string) => string) | null, options?: HandleDialogOptions): ControllerPromise;
    handleBeforeunloadDialog(fn?: ((text?: string, url?: string) => boolean) | null, options?: HandleDialogOptions): ControllerPromise;
    handleNativeDialog(fn: ((type: 'alert' | 'confirm' | 'beforeunload' | 'prompt', text?: string, url?: string) => any) | null, options?: HandleDialogOptions): ControllerPromise;
    setCookie(cookie: {
        name: string;
        value: string;
        domain?: string;
        path?: string;
        expires?: Date;
        secure?: boolean;
        sameSite?: `Lax` | `Strict` | `None`;
    }): ControllerPromise;
    getCookie(cookieName: string): Promise<Cookie | null>;
    clearCookie(cookieName: string): ControllerPromise;
    deleteCookie(cookieName: string): ControllerPromise;
    setLocalStorage(name: string, value: string): ControllerPromise;
    getLocalStorage(name: string): Promise<string | null>;
    removeLocalStorage(name: string): ControllerPromise;
    setSessionStorage(name: string, value: string): ControllerPromise;
    getSessionStorage(name: string): Promise<string | null>;
    removeSessionStorage(name: string): ControllerPromise;
    injectCss({ code, filePath, name, position }: {
        code?: string;
        filePath?: string;
        name?: string;
        position?: 'head' | 'bodyTop' | 'bodyBottom';
    }): ControllerPromise;
    injectJs({ code, filePath, name, position }: {
        code?: string;
        filePath?: string;
        name?: string;
        position?: 'head' | 'bodyTop' | 'bodyBottom';
    }): ControllerPromise;
}
interface ControllerUtilActions {
    eval<Arg, R>(fn: (arg: ClientFunctionArgs<Arg>) => R | Promise<R>, arg?: ClientFunctionArgs<Arg>): Promise<R>;
    evalInMainWindowMainFrame<Arg, R>(fn: (arg: ClientFunctionArgs<Arg>) => R | Promise<R>, arg?: ClientFunctionArgs<Arg>): Promise<R>;
    evalInCurrentWindowMainFrame<Arg, R>(fn: (arg: ClientFunctionArgs<Arg>) => R | Promise<R>, arg?: ClientFunctionArgs<Arg>): Promise<R>;
    evalInAllFrames<Arg, R>(options: EvalInAllFramesOptions<Arg, R>): Promise<any[]>;
    getClientInfo(): Promise<ClientInfo>;
    wait(timeout: number): ControllerPromise;
    waitForCondition(options: WaitForConditionOptions): ControllerPromise;
    waitForSelectorToExist(selector: selectorType): ControllerPromise;
    waitForSelectorToNotExist(selector: selectorType): ControllerPromise;
    waitForSelectorToBeVisible(selector: selectorType): ControllerPromise;
    waitForSelectorToBeInvisible(selector: selectorType): ControllerPromise;
    waitForSelectActionabilityCheck(selector: selectorType, checks: ActionabilityCheckTypes[]): ControllerPromise;
    waitForFrameToLoad(selector: selectorType, options?: WaitFrameToLodOptions): ControllerPromise;
    waitForVisualState(WaitForVisualStateOptions: WaitForVisualStateOptions): WaitForVisualStateResult;
    expect(actual: any, options?: AssertOptions): Matchers;
    expectSelector(actual: selectorType, options?: AssertOptions): SelectorMatchers;
    debugger(): ControllerPromise;
    takeScreenshot(path: string, options?: {
        fullPage: boolean;
    }): ControllerPromise;
    takeSelectorScreenshot(selector: selectorType, path: string): ControllerPromise;
    recordVideo(options: RecordVideoOptions): Promise<{
        id: string;
        pause: () => Promise<void>;
        resume: () => Promise<void>;
        stop: () => Promise<void>;
    }>;
    emulateNetworkConditions(condition: NetworkConditionPreset | NetworkCondition): ControllerPromise;
    getClientLogs(): Promise<ClientLogs>;
    /**
     * We can use placeholders, pipes, etc...
     *
     * @example ```typescript
     * await I.log('hello {{name}}',{data:{name:'mike'}})
     * // We can use built in pipes or register custom ones
     * // we can use any [lodash](https://lodash.com/docs) methods
     * await I.log('hello {{name|_.truncate(options)}}',{data:{name:'mike'}})
     * // we can use any [string-kit](https://www.npmjs.com/package/string-kit) methods
     * await I.log('price: {{1.50|%[3]f)}}',{data:{price:120}})
     * ```
     */
    getScrollPosition(): Promise<{
        left: number;
        top: number;
    }>;
    getTitle(): Promise<string>;
    getSource(): Promise<string>;
    getCurrentUrl(): Promise<string>;
    addReporterAttachment({ name, content, path, mimeType }: {
        name?: string;
        content?: Buffer | string;
        path?: string;
        mimeType: AttachmentTypes;
    }): Promise<void>;
    addScreenshotReporterAttachment({ filePath, title }: AddImageReporterAttachmentOptions): Promise<void>;
    addImageReporterAttachment({ title, filePath }: AddImageReporterAttachmentOptions): Promise<void>;
    addTextReporterAttachment({ title, content }: AddTextReporterAttachmentOptions): Promise<void>;
    addHtmlReporterAttachment({ title, content }: AddTextReporterAttachmentOptions): Promise<void>;
}
interface ControllerClipboardActions {
    cut({ value, selector, format, store }?: {
        value?: string;
        selector?: selectorType;
        format?: 'text/plain' | 'text/html' | 'default';
        store?: {
            value: string;
        };
    }): ControllerPromise;
    copy({ value, selector, format, store }?: {
        value?: string;
        selector?: selectorType;
        format?: 'text/plain' | 'text/html' | 'default';
        store?: {
            value: string;
        };
    }): ControllerPromise;
    paste(to?: selectorType, store?: {
        value: string;
    }): ControllerPromise;
}
interface ControllerDeviceActions {
    launchApp: ({ id, path, type, args }: {
        id: string;
        path: string;
        type?: string;
        args?: any[];
    }) => ControllerPromise;
    closeApp: (id: string) => ControllerPromise;
    switchToApp: (id: string) => ControllerPromise;
    switchContext: (id: string) => Promise<string>;
    getContext: () => Promise<string | null>;
    getContexts: () => Promise<(string | null)[]>;
    getOrientation: () => Promise<string>;
    setOrientation: (orientation: `LANDSCAPE` | `PORTRAIT`) => Promise<void>;
    getGeoLocation: () => Promise<{
        latitude: number;
        longitude: number;
        altitude: number;
    }>;
    setGeoLocation: (location: {
        latitude: number;
        longitude: number;
        altitude: number;
    }) => Promise<void>;
}
interface SocketEvents {
    triggerClientEvent(eventName: string, data?: {
        [key: string]: any;
    }): ControllerPromise;
    handleClientEvent(eventName: string, fn: (data?: {
        [key: string]: any;
    }) => Promise<void>): ControllerPromise;
    triggerServerEvent(eventName: string, data?: {
        [key: string]: any;
    }): ControllerPromise;
    handleServerEvent(eventName: string, fn: (data?: {
        [key: string]: any;
    }) => Promise<any>): ControllerPromise;
}
interface HTTPRequest {
    sendGetRequest<T = any, R = HttpClientResponse<T>>(url: string, config?: HttpRequestConfig): Promise<R>;
    sendDeleteRequest<T = any, R = HttpClientResponse<T>>(url: string, config?: HttpRequestConfig): Promise<R>;
    sendHeadRequest<T = any, R = HttpClientResponse<T>>(url: string, config?: HttpRequestConfig): Promise<R>;
    sendPostRequest<T = any, R = HttpClientResponse<T>>(url: string, data?: any, config?: HttpRequestConfig): Promise<R>;
    sendPutRequest<T = any, R = HttpClientResponse<T>>(url: string, data?: any, config?: HttpRequestConfig): Promise<R>;
    sendPatchRequest<T = any, R = HttpClientResponse<T>>(url: string, data?: any, config?: HttpRequestConfig): Promise<R>;
}
interface Network {
    handleRoute({ url, handler }: HandleRouteParams): ControllerPromise;
}
interface Email {
    sendMail({ mailOptions, transport, transportDefaults }: SendMailOptions): Promise<SMTPTransport.SentMessageInfo>;
    parseMail({ source, options }: ParseMailParameters): Promise<ParsedMail>;
    createTestMailAccount(apiUrl: string | undefined): Promise<TestAccount>;
}
interface PDF {
    parsePDF(filePath: string): Promise<JsonPdf>;
}
interface Benchmark {
    benchmark({ name, functions, options }: {
        name: string;
        functions: {
            name: string;
            fn: () => Promise<void>;
        }[];
        options?: BenchmarkOptions;
    }): Promise<BenchmarkResult>;
}
interface Tracing {
    startTracing({ path }: {
        path: string;
    }): ControllerPromise;
    stopTracing(): ControllerPromise;
}
interface HUDInfo {
    updateInfoHud: (extraInfo: string) => ControllerPromise;
    enableInfoHud: () => ControllerPromise;
    disableInfoHud: () => ControllerPromise;
}
interface Fake {
    fake: (options?: DataFakerOptions) => DataFaker;
}
export interface Controller extends ControllerFormActions, GenericActions, ControllerButtonActions, ControllerMouseActions, ControllerTextActions, ControllerFileActions, ControllerScrollActions, ControllerBrowserActions, ControllerClipboardActions, ControllerDeviceActions, SocketEvents, HTTPRequest, Network, Email, PDF, Benchmark, Tracing, HUDInfo, Fake, ControllerUtilActions {
    ctx: {
        [key: string]: any;
    };
    updateConfiguration: (updatedConfiguration: DeepPartial<Configuration>) => ControllerPromise;
    restoreConfiguration: () => ControllerPromise;
}
export {};
