import { ActionabilityCheckTypes } from "../actionability-check-types";
import { AssertOptions } from "../assertion/assert-options";
import { SelectorMatchers } from "../assertion/selector-matchers";
import { DragToSelectorOptions } from "../controller/drag-to-selector-options";
import { FillActionOptions } from "../controller/fill-action-options";
import { KeyModifiers } from "../controller/key-modifiers";
import { TextRectangle } from "../controller/text-rectangles";
import { Selector } from "./selector";
import { SelectorControllerPromise } from "./selector-controller-action-promise";
import { SelectorOptions } from "./selector-options";
import { selectorType } from "./selector-type";
export interface SelectorControllerActions<T> {
    expect(options?: AssertOptions): SelectorMatchers;
    fillField(text: string | number, options?: FillActionOptions): T;
    appendField(text: string | number, options?: FillActionOptions): T;
    clearField(): T;
    select(): T;
    selectOption(option: string | number | {
        label?: string;
        value?: string;
        index?: number;
    } | string[] | number[] | {
        label?: string;
        value?: string;
        index?: number;
    }[]): T;
    deselectOption(option: string | number | {
        label?: string;
        value?: string;
        index?: number;
    } | string[] | number[] | {
        label?: string;
        value?: string;
        index?: number;
    }[]): T;
    checkOption(): T;
    uncheckOption(): T;
    focus(selector: selectorType): T;
    blur(selector: selectorType): T;
    click(options?: {
        modifiers?: KeyModifiers;
    }): T;
    doubleClick(options?: {
        modifiers?: KeyModifiers;
    }): T;
    middleClick(options?: {
        modifiers?: KeyModifiers;
    }): T;
    rightClick(options?: {
        modifiers?: KeyModifiers;
    }): T;
    hover(options?: {
        modifiers?: KeyModifiers;
    }): T;
    drag(dragOffsetX: number, dragOffsetY: number, options?: DragToSelectorOptions): T;
    dragToSelector(destinationSelector: selectorType, options?: DragToSelectorOptions): T;
    moveCursorToSelector(offsetX?: number, offsetY?: number): T;
    selectText(startPos?: number, endPos?: number): T;
    selectEditableContent(endSelector: selectorType): T;
    selectTextAreaContent({ startLine, startPosition, endLine, endPosition }: {
        startLine?: number;
        startPosition?: number;
        endLine?: number;
        endPosition?: number;
    }): T;
    upload(filePath?: string | string[]): T;
    setFilesToUpload(filePath: string | string[]): T;
    clearUpload(): T;
    waitForToExist(): T;
    waitForToNotExist(): T;
    waitForToBeVisible(): T;
    waitForToBeInvisible(): T;
    waitForActionabilityCheck(checks: ActionabilityCheckTypes[]): T;
    waitForFrameToLoad(): T;
}
export interface SelectorApi extends SelectorControllerActions<SelectorControllerPromise> {
    id: Promise<string>;
    tagName: Promise<string>;
    nodeType: Promise<number>;
    namespaceURI: Promise<string | null>;
    className: Promise<string>;
    classNames: Promise<string[]>;
    focused: Promise<boolean>;
    visible: Promise<boolean>;
    attached: Promise<boolean>;
    stable: Promise<boolean>;
    editable: Promise<boolean>;
    clickable: Promise<boolean>;
    inViewport: Promise<boolean>;
    inViewportPartially: Promise<boolean>;
    enabled: Promise<boolean>;
    disabled: Promise<boolean>;
    exists: Promise<boolean>;
    count: Promise<number>;
    checked: Promise<boolean | undefined>;
    selected: Promise<boolean | undefined>;
    selectedIndex: Promise<number | undefined>;
    value: Promise<string | undefined>;
    nodeValue: Promise<string | null>;
    textContent: Promise<string>;
    innerText: Promise<string>;
    innerHTML: Promise<string>;
    outerHTML: Promise<string>;
    style: Promise<{
        [prop: string]: string;
    }>;
    childElementCount: Promise<number>;
    childNodeCount: Promise<number>;
    hasChildElements: Promise<boolean>;
    hasChildNodes: Promise<boolean>;
    attributes: Promise<{
        [name: string]: string;
    }>;
    clientHeight: Promise<number>;
    clientLeft: Promise<number>;
    clientTop: Promise<number>;
    clientWidth: Promise<number>;
    offsetHeight: Promise<number>;
    offsetLeft: Promise<number>;
    offsetTop: Promise<number>;
    offsetWidth: Promise<number>;
    scrollHeight: Promise<number>;
    scrollLeft: Promise<number>;
    scrollTop: Promise<number>;
    scrollWidth: Promise<number>;
    boundingClientRect: Promise<TextRectangle>;
    hasClass(className: string): Promise<boolean>;
    hasAttribute(attributeName: string): Promise<boolean>;
    getAttribute(attributeName: string): Promise<string>;
    getStyleProperty(propertyName: string): Promise<string>;
    getBoundingClientRectProperty(propertyName: string): Promise<number>;
    nth(index: number): Selector;
    withText(value: string | RegExp): Selector;
    withExactText(text: string): Selector;
    withAttribute(attrName: string | RegExp, attrValue?: string | RegExp): Selector;
    filter(cssSelector: string): Selector;
    filter(xPathSelector: string): Selector;
    filter(filterFn: (node: Element, idx?: number) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    filterVisible(): Selector;
    filterHidden(): Selector;
    find(cssSelector: string): Selector;
    find(xPathSelector: string): Selector;
    find(filterFn: (node: Element, idx?: number, originNode?: Element) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    parent(index?: number): Selector;
    parent(cssSelector: string): Selector;
    parent(xPathSelector: string): Selector;
    parent(filterFn: (node: Element, idx?: number, originNode?: Element) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    child(index?: number): Selector;
    child(cssSelector: string): Selector;
    child(xPathSelector: string): Selector;
    child(filterFn: (node: Element, idx?: number, originNode?: Element) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    sibling(index?: number): Selector;
    sibling(cssSelector: string): Selector;
    sibling(xPathSelector: string): Selector;
    sibling(filterFn: (node: Element, idx?: number, originNode?: Element) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    nextSibling(index?: number): Selector;
    nextSibling(cssSelector: string): Selector;
    nextSibling(xPathSelector: string): Selector;
    nextSibling(filterFn: (node: Element, idx?: number, originNode?: Element) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    prevSibling(index?: number): Selector;
    prevSibling(cssSelector: string): Selector;
    prevSibling(xPathSelector: string): Selector;
    prevSibling(filterFn: (node: Element, idx?: number, originNode?: Element) => boolean, dependencies?: {
        [key: string]: any;
    }): Selector;
    all: () => Promise<Selector[]>;
    clone(cloneActions?: boolean): Selector;
    with(options?: SelectorOptions): Selector;
    expect(options?: AssertOptions): SelectorMatchers;
}
