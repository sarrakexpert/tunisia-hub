/**
 * Just a type alias to one-argument-async-function...
 */
export declare type Lambda<T, R> = (entity: T) => Promise<R>;
/**
 * An interface for the "object" version of Lambda
 */
export interface Fn<T, R> {
    call(entity: T): Promise<R>;
}
/**
 * We use queries to perform an async query on entity of type T, i.e. get something from entity.
 * So a query can pass and return something of type R or failed with Error correspondingly.
 */
export declare class Query<T, R> implements Fn<T, R> {
    private readonly description;
    private readonly fn;
    constructor(description: any, fn: any);
    call(entity: T): Promise<R>;
    toString(): string;
}
/**
 * Commands we use in a normal "command" case, i.e. to perform the async command on entity of type T.
 * Command can pass or fail with Error correspondingly.
 */
export declare class Command<T> extends Query<T, void> {
}
/**
 * Like Command<T>, i.e. can pass or fail with Error.
 * It is defined as separate type alias to differentiate the usage scenarios.
 * Conditions we use in context of matching condition on entity.
 * Condition is like a predicate but instead of (true | false) you get (passed | throws Error)
 *
 * Read "void" in Query<T, void> as "matched", or "passed".
 */
export declare class Condition<E> implements Fn<E, void> {
    private readonly description;
    private readonly fn;
    constructor(description: any, fn: any);
    call(entity: E): Promise<void>;
    and(condition: Condition<E>): any;
    or(condition: Condition<E>): Condition<E>;
    toString(): string;
}
export declare namespace Condition {
    /**
     * Negates condition. Making the negated condition to:
     * - pass (return void) in case original condition would throw Error
     * - throw Error in case original condition would pass (return void)
     *
     * @param {Condition<T>} condition - original condition to be negated
     * @param {string} description - custom description if "not <original description>" version is not enough
     * @returns {Condition<T>}
     */
    const not: <T>(condition: Condition<T>, description?: string) => Condition<T>;
    /**
     * Combines conditions by logical AND
     *
     * @param {Condition<T>} conditions
     * @returns {Condition<T>}
     */
    const and: <T>(...conditions: Condition<T>[]) => Condition<T>;
    /**
     * Combines conditions by logical OR
     * @param {Condition<T>} conditions
     * @returns {Condition<T>}
     */
    const or: <T>(...conditions: Condition<T>[]) => Condition<T>;
    /**
     * Transforms conditions array provided as varargs to condition by applying Condition.and
     * @param {Array<Condition<T>>} conditions
     * @returns {Condition<T>}
     */
    const all: <T>(...conditions: Condition<T>[]) => Condition<T>;
    /**
     * Transforms conditions array provided as varargs to condition by applying Condition.and
     * @param {Array<Condition<T>>} conditions
     * @returns {Condition<T>}
     */
    const allNot: <T>(...conditions: Condition<T>[]) => Condition<T>;
    /**
     * Transforms Conditions (returning (void | throws Error)), combined by AND if more than one,
     * to async Predicate   (returning (true | false))
     * @param {Array<Condition<T>>} conditions
     * @returns {(entity: T) => Promise<boolean>}
     */
    const asPredicate: <T>(...conditions: Condition<T>[]) => (entity: T) => Promise<boolean>;
}
export declare type OnFailureHook<T> = (failure: Error, entity: T) => Promise<void | Error>;
export declare class Wait<T> {
    private readonly entity;
    private readonly timeout;
    constructor(entity: T, timeout: number);
    query<R>(fn: Lambda<T, R>): Promise<R>;
    command(fn: Lambda<T, void>): Promise<void>;
    until<R>(fn: Fn<T, R>): Promise<boolean>;
    for<R>(fn: Fn<T, R>): Promise<R>;
}
