"use strict";
// Copyright 2018 Knowledge Expert SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.condition = void 0;
const selenium_webdriver_1 = require("selenium-webdriver");
const conditionDoesNotMatchError_1 = require("./errors/conditionDoesNotMatchError");
const queries_1 = require("./queries");
const predicates_1 = require("./utils/predicates");
const wait_1 = require("./wait");
/**
 * The list of predefined conditions for all type of entities:
 * - condition.element.*
 * - condition.collection.*
 * - condition.browser.*
 *
 * Can be used in the following way:
 * ```
 *     await browser.all('.google-result').should(condition.collection.have.size(10))
 * ```
 *
 * Yet there are more handy aliases in be.* and have.* namespaces:
 * ```
 *     await browser.all('.google-result').should(have.size(10))
 * ```
 *
 * All conditions (Condition<T>) are just predicate-like functions on entity of corresponding type (T),
 * wrapped into Condition object: `new Condition(description, predicateLikeFn)`
 * The "predicate-like" function should:
 *  - pass (returning void) in case when a "normal predicate" version would return true
 *  - throw Error in case when a "normal predicate"  would return false
 *
 * The following example shows how a condition can be implemented:
 * ```ts
 *     export function hasText(expected: string): ElementCondition {
 *         return new Condition(`has text: ${expected}`, async (element: Element) => {
 *             const actual = await element.getWebElement().then(it => it.getText());
 *             if (!actual.includes(expected)) {
 *                 throw new Error(`actual text: ${actual}`);
 *             }
 *         })
 *     }
 * ```
 *
 * Or more concise by using arrow functions:
 * ```ts
 *     export const hasText = (expected: string): ElementCondition =>
 *         new Condition(`has text: ${expected}`, async (element: Element) => {
 *             const actual = await element.getWebElement().then(it => it.getText());
 *             if (!actual.includes(expected)) {
 *                 throw new Error(`actual text: ${actual}`);
 *             }
 *         });
 * ```
 *
 * We can refactor the code above even more, if notice,
 * that the actual condition reflects a simple rule:
 * - throw error if actual value (returned from some query on element like "getting its text")
 *   does not satisfy the predicate (like includes expected text)
 * If we abstract this "throw error if not predicate(actual)" into some function like throwIfNotActual,
 * The code will become very concise and declarative:
 * ```ts
 *     export const hasText = (expected: string): ElementCondition =>
 *         new Condition(`has text: ${expected}`,
 *                throwIfNotActual(query.text, predicate.includes(expected)));
 * ```
 *
 * This is how predefined in selenidejs conditions are implemented below.
 *
 * Have fun;)
 */
var condition;
(function (condition) {
    /**
     * Creates condition from async query
     * @param {(entity: E) => Promise<boolean>} predicate
     * @returns {Condition<E>}
     */
    function throwIfNot(predicate) {
        return async (entity) => {
            if (!await predicate(entity)) {
                throw new conditionDoesNotMatchError_1.ConditionNotMatchedError();
            }
        };
    }
    /**
     * Transforms an entity query compared through predicate - to Condition
     * Example: throwIfNotActual(query.text, predicate.equals(text))
     */
    function throwIfNotActual(query, predicate) {
        return async (entity) => {
            const actual = await query(entity);
            if (!predicate(actual)) {
                throw new Error(`actual ${query}: ${actual}`);
            }
        };
    }
    let element;
    (function (element_1) {
        element_1.isVisible = new wait_1.Condition('is visible', throwIfNot(async (element) => element.getWebElement().then(webelement => webelement.isDisplayed())));
        element_1.isHidden = wait_1.Condition.not(element_1.isVisible, 'is hidden');
        element_1.hasAttribute = (name) => new wait_1.Condition(`has attribute '${name}'`, throwIfNotActual(queries_1.query.attribute(name), predicates_1.predicate.isTruthy));
        element_1.isSelected = element_1.hasAttribute('elementIsSelected');
        element_1.isEnabled = new wait_1.Condition('is enabled', throwIfNot(async (element) => element.getWebElement().then(webelement => webelement.isEnabled())));
        element_1.isDisabled = wait_1.Condition.not(element_1.isEnabled, 'is disabled');
        element_1.isPresent = new wait_1.Condition('is present', throwIfNot(async (element) => element.getWebElement().then(_ => true, _ => false)));
        element_1.isAbsent = wait_1.Condition.not(element_1.isPresent, 'is absent');
        element_1.isFocused = new wait_1.Condition('is focused', throwIfNot(async (element) => selenium_webdriver_1.WebElement.equals(await element.executeScript('return document.activeElement'), await element.getWebElement())));
        element_1.hasText = (expected) => new wait_1.Condition(`has text: ${expected}`, throwIfNotActual(queries_1.query.text, typeof expected === 'string'
            ? predicates_1.predicate.includes(expected)
            : predicates_1.predicate.matches(expected)));
        element_1.hasExactText = (expected) => new wait_1.Condition(`has exact text: ${expected}`, throwIfNotActual(queries_1.query.text, predicates_1.predicate.equals(expected)));
        element_1.hasAttributeWithValue = (name, value) => new wait_1.Condition(`has attribute '${name}' with value '${value}'`, throwIfNotActual(queries_1.query.attribute(name), predicates_1.predicate.equals(value)));
        element_1.hasAttributeWithValueContaining = (name, partialValue) => new wait_1.Condition(`has attribute '${name}' with value '${partialValue}'`, throwIfNotActual(queries_1.query.attribute(name), predicates_1.predicate.includes(partialValue)));
        element_1.hasCssClass = (cssClass) => new wait_1.Condition(`has css class '${cssClass}'`, throwIfNotActual(queries_1.query.attribute('class'), predicates_1.predicate.includesWord(cssClass)));
        element_1.hasValue = (expected) => element_1.hasAttributeWithValue('value', expected);
        element_1.hasValueContaining = (expected) => element_1.hasAttributeWithValueContaining('value', expected);
        // TODO do we need to have message `should have text '' but was ... and value '' but was ...`
        // or we can do just `should be blank` ?
        element_1.isBlank = element_1.hasExactText('').and(element_1.hasValue(''));
    })(element = condition.element || (condition.element = {}));
    let collection;
    (function (collection) {
        collection.hasSize = (expected) => new wait_1.Condition(`has size ${expected}`, throwIfNotActual(queries_1.query.size, predicates_1.predicate.equals(expected)));
        collection.hasSizeGreaterThan = (size) => new wait_1.Condition(`has size more than ${size}`, throwIfNotActual(queries_1.query.size, predicates_1.predicate.isGreaterThan(size)));
        collection.hasSizeGreaterThanOrEqual = (size) => new wait_1.Condition(`has size more than ${size}`, throwIfNotActual(queries_1.query.size, predicates_1.predicate.isGreaterThanOrEqual(size)));
        collection.hasSizeLessThan = (size) => new wait_1.Condition(`has size less than ${size}`, throwIfNotActual(queries_1.query.size, predicates_1.predicate.isLessThan(size)));
        collection.hasSizeLessThanOrEqual = (size) => new wait_1.Condition(`has size less than ${size}`, throwIfNotActual(queries_1.query.size, predicates_1.predicate.isLessThanOrEqual(size)));
        // todo: should we filter collection for visibility before applying this condition?
        // update: for invisible element `getText` will return error or empty string, and
        // it can be confused with message like `but was 'foo', '', 'bar'` when he see on
        // screen only 'foo', 'bar'
        collection.hasTexts = (texts) => new wait_1.Condition(`has texts ${texts}`, throwIfNotActual(queries_1.query.texts, predicates_1.predicate.equalsByContainsToArray(texts)));
        collection.hasExactTexts = (texts) => new wait_1.Condition(`has exact texts ${texts}`, throwIfNotActual(queries_1.query.texts, predicates_1.predicate.equalsByContainsToArray(texts)));
    })(collection = condition.collection || (condition.collection = {}));
    let browser;
    (function (browser_1) {
        // todo: do we need string | number
        browser_1.hasUrlContaining = (partialUrl) => new wait_1.Condition(`has url containing ${partialUrl}`, throwIfNotActual(queries_1.query.url, predicates_1.predicate.includes(partialUrl)));
        browser_1.hasUrl = (url) => new wait_1.Condition(`has url ${url}`, throwIfNotActual(queries_1.query.url, predicates_1.predicate.equals(url)));
        browser_1.hasTitle = (title) => new wait_1.Condition(`has title ${title}`, throwIfNotActual(queries_1.query.title, predicates_1.predicate.equals(title)));
        browser_1.hasTitleContaining = (partialTitle) => new wait_1.Condition(`has title containing ${partialTitle}`, throwIfNotActual(queries_1.query.title, predicates_1.predicate.includes(partialTitle)));
        browser_1.hasTabsNumber = (num) => new wait_1.Condition(`has tabs number ${num}`, throwIfNotActual(queries_1.query.tabsNumber, predicates_1.predicate.equals(num)));
        browser_1.hasTabsNumberMoreThan = (num) => new wait_1.Condition(`has tabs number more than ${num}`, throwIfNotActual(queries_1.query.tabsNumber, predicates_1.predicate.isGreaterThan(num)));
        browser_1.hasTabsNumberLessThan = (num) => new wait_1.Condition(`has tabs number less than ${num}`, throwIfNotActual(queries_1.query.tabsNumber, predicates_1.predicate.isLessThan(num)));
        browser_1.hasJsReturned = (expected, script, ...args) => new wait_1.Condition(`has execute script returned ${JSON.stringify(expected)}`, async (browser) => {
            const actual = await browser.executeScript(script, ...args);
            if (typeof expected === 'number' || typeof expected === 'string') {
                if (expected !== actual) {
                    throw new Error(`actual: ${actual}`);
                }
            }
            else if (predicates_1.predicate.equals(expected)(actual)) {
                throw new Error(`actual: ${JSON.stringify(actual)}`);
            }
        });
    })(browser = condition.browser || (condition.browser = {}));
})(condition = exports.condition || (exports.condition = {}));
//# sourceMappingURL=conditions.js.map