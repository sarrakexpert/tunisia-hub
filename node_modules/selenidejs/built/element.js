"use strict";
// Copyright 2018 Knowledge Expert SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Element = void 0;
const selenium_webdriver_1 = require("selenium-webdriver");
const collection_1 = require("./collection");
const commands_1 = require("./commands");
const configuration_1 = require("./configuration");
const entity_1 = require("./entity");
const ElementWebElementByJs_1 = require("./locators/ElementWebElementByJs");
const ElementWebElementByLocator_1 = require("./locators/ElementWebElementByLocator");
const ElementWebElementsByJs_1 = require("./locators/ElementWebElementsByJs");
const ElementWebElementsByLocator_1 = require("./locators/ElementWebElementsByLocator");
const by_1 = require("./support/selectors/by");
const utils_1 = require("./utils");
const shadow_1 = require("./shadow");
class Element extends entity_1.Entity {
    constructor(locator, configuration) {
        super(configuration);
        this.locator = locator;
    }
    toString() {
        return this.locator.toString();
    }
    async getWebElement() {
        return this.locator.find();
    }
    /* Relative search */
    with(customConfig) {
        return new Element(this.locator, new configuration_1.Configuration(Object.assign(Object.assign({}, this.configuration), customConfig)));
    }
    element(located, customized) {
        const configuration = customized === undefined
            ? this.configuration
            : new configuration_1.Configuration(Object.assign(Object.assign({}, this.configuration), customized));
        if (located instanceof selenium_webdriver_1.By || typeof located === 'string') {
            const byLocator = located instanceof selenium_webdriver_1.By ? located : this.configuration._locationStrategy(located);
            const locator = new ElementWebElementByLocator_1.ElementWebElementByLocator(byLocator, this);
            return new Element(locator, configuration);
        }
        const locator = new ElementWebElementByJs_1.ElementWebElementByJs(this, located.script, located.args);
        return new Element(locator, configuration);
    }
    all(located, customized) {
        const configuration = customized === undefined
            ? this.configuration
            : new configuration_1.Configuration(Object.assign(Object.assign({}, this.configuration), customized));
        if (located instanceof selenium_webdriver_1.By || typeof located === 'string') {
            const byLocator = located instanceof selenium_webdriver_1.By ? located : this.configuration._locationStrategy(located);
            const locator = new ElementWebElementsByLocator_1.ElementWebElementsByLocator(byLocator, this);
            return new collection_1.Collection(locator, configuration);
        }
        const locator = new ElementWebElementsByJs_1.ElementWebElementsByJs(this, located.script, located.args);
        return new collection_1.Collection(locator, configuration);
    }
    get parent() {
        return this.element(by_1.by.xpath('./..'));
    }
    get followingSibling() {
        return this.element(by_1.by.xpath('./following-sibling::*'));
    }
    get shadow() {
        return new shadow_1.Shadow(this.element({ script: element => element.shadowRoot }), this.configuration);
    }
    get driver() {
        return this.config.driver;
    }
    /* Commands */
    async executeScript(script, ...args) {
        const wrappedScript = `var [ element, ...args ] = arguments;${script instanceof Function
            ? `return (${script.toString()})(element, args, window);`
            : `return (function(element, args, window) { ${script} })(element, args, window);`}`;
        const webelement = await this.getWebElement();
        return this.driver.executeScript(wrappedScript, webelement, ...args);
    }
    async click() {
        await this.wait.command((0, utils_1.lambda)('click', async (element) => element.getWebElement().then(it => it.click())));
        return this;
    }
    async clear() {
        await this.wait.command((0, utils_1.lambda)('clear', async (element) => element.getWebElement().then(it => it.clear())));
        return this;
    }
    async setValue(value) {
        // kind of more readable and reflects user context
        await this.wait.command(this.configuration.setValueByJs
            ? commands_1.command.js.setValue(value)
            : (0, utils_1.lambda)(`set value: ${value}`, async (element) => {
                const webelement = await element.getWebElement();
                await webelement.clear();
                await webelement.sendKeys(String(value));
            }));
        return this;
    }
    async type(keys) {
        await this.wait.command(this.configuration.typeByJs
            ? commands_1.command.js.type(keys)
            : (0, utils_1.lambda)(`type: ${keys}`, async (element) => element.getWebElement().then(it => it.sendKeys(String(keys)))));
        return this;
    }
    async doubleClick() {
        await this.wait.command((0, utils_1.lambda)('double-click', async (element) => {
            const webelement = await element.getWebElement();
            if (!await webelement.isDisplayed()) {
                throw new Error('element is hidden'); // todo: consider refactoring/DRYing to throwErrorIfHidden(webel)
            }
            this.driver.actions().doubleClick(webelement).perform();
        }));
        return this;
    }
    async hover() {
        await this.wait.command((0, utils_1.lambda)('hover', async (element) => {
            const webelement = await element.getWebElement();
            if (!await webelement.isDisplayed()) {
                throw new Error('element is hidden');
            }
            this.driver.actions().move({
                x: 0, y: 0, duration: 100, origin: await element.getWebElement(),
            }).perform();
        }));
        return this;
    }
    async contextClick() {
        await this.wait.command((0, utils_1.lambda)('context-click', async (element) => {
            const webelement = await element.getWebElement();
            if (!await webelement.isDisplayed()) {
                throw new Error('element is hidden');
            }
            this.driver.actions().contextClick(await element.getWebElement()).perform();
        }));
        return this;
    }
    // async switchToFrame(): Promise<Element> {
    //     await this.wait.command(lambda('switch to frame', async element =>
    //         this.driver.switchTo().frame(await element.getWebElement())
    //     ));
    //     return this;
    // }
    async pressEnter() {
        return this.type(selenium_webdriver_1.Key.ENTER);
    }
    async pressEscape() {
        return this.type(selenium_webdriver_1.Key.ESCAPE);
    }
    async pressTab() {
        return this.type(selenium_webdriver_1.Key.TAB);
    }
}
exports.Element = Element;
//# sourceMappingURL=element.js.map