import { Browser } from './browser';
import { Collection } from './collection';
import { Element } from './element';
import { Condition } from './wait';
export declare type ElementCondition = Condition<Element>;
export declare type CollectionCondition = Condition<Collection>;
export declare type BrowserCondition = Condition<Browser>;
/**
 * The list of predefined conditions for all type of entities:
 * - condition.element.*
 * - condition.collection.*
 * - condition.browser.*
 *
 * Can be used in the following way:
 * ```
 *     await browser.all('.google-result').should(condition.collection.have.size(10))
 * ```
 *
 * Yet there are more handy aliases in be.* and have.* namespaces:
 * ```
 *     await browser.all('.google-result').should(have.size(10))
 * ```
 *
 * All conditions (Condition<T>) are just predicate-like functions on entity of corresponding type (T),
 * wrapped into Condition object: `new Condition(description, predicateLikeFn)`
 * The "predicate-like" function should:
 *  - pass (returning void) in case when a "normal predicate" version would return true
 *  - throw Error in case when a "normal predicate"  would return false
 *
 * The following example shows how a condition can be implemented:
 * ```ts
 *     export function hasText(expected: string): ElementCondition {
 *         return new Condition(`has text: ${expected}`, async (element: Element) => {
 *             const actual = await element.getWebElement().then(it => it.getText());
 *             if (!actual.includes(expected)) {
 *                 throw new Error(`actual text: ${actual}`);
 *             }
 *         })
 *     }
 * ```
 *
 * Or more concise by using arrow functions:
 * ```ts
 *     export const hasText = (expected: string): ElementCondition =>
 *         new Condition(`has text: ${expected}`, async (element: Element) => {
 *             const actual = await element.getWebElement().then(it => it.getText());
 *             if (!actual.includes(expected)) {
 *                 throw new Error(`actual text: ${actual}`);
 *             }
 *         });
 * ```
 *
 * We can refactor the code above even more, if notice,
 * that the actual condition reflects a simple rule:
 * - throw error if actual value (returned from some query on element like "getting its text")
 *   does not satisfy the predicate (like includes expected text)
 * If we abstract this "throw error if not predicate(actual)" into some function like throwIfNotActual,
 * The code will become very concise and declarative:
 * ```ts
 *     export const hasText = (expected: string): ElementCondition =>
 *         new Condition(`has text: ${expected}`,
 *                throwIfNotActual(query.text, predicate.includes(expected)));
 * ```
 *
 * This is how predefined in selenidejs conditions are implemented below.
 *
 * Have fun;)
 */
export declare namespace condition {
    namespace element {
        const isVisible: Condition<unknown>;
        const isHidden: Condition<unknown>;
        const hasAttribute: (name: string) => Condition<unknown>;
        const isSelected: Condition<unknown>;
        const isEnabled: Condition<unknown>;
        const isDisabled: Condition<unknown>;
        const isPresent: Condition<unknown>;
        const isAbsent: Condition<unknown>;
        const isFocused: Condition<unknown>;
        const hasText: (expected: string | number | RegExp) => Condition<unknown>;
        const hasExactText: (expected: string | number) => Condition<unknown>;
        const hasAttributeWithValue: (name: string, value: string | number) => Condition<unknown>;
        const hasAttributeWithValueContaining: (name: string, partialValue: string | number) => Condition<unknown>;
        const hasCssClass: (cssClass: string) => Condition<unknown>;
        const hasValue: (expected: string | number) => Condition<unknown>;
        const hasValueContaining: (expected: string | number) => Condition<unknown>;
        const isBlank: any;
    }
    namespace collection {
        const hasSize: (expected: number) => CollectionCondition;
        const hasSizeGreaterThan: (size: number) => CollectionCondition;
        const hasSizeGreaterThanOrEqual: (size: number) => CollectionCondition;
        const hasSizeLessThan: (size: number) => CollectionCondition;
        const hasSizeLessThanOrEqual: (size: number) => CollectionCondition;
        const hasTexts: (texts: string[] | number[]) => CollectionCondition;
        const hasExactTexts: (texts: string[] | number[]) => CollectionCondition;
    }
    namespace browser {
        const hasUrlContaining: (partialUrl: string) => BrowserCondition;
        const hasUrl: (url: string) => BrowserCondition;
        const hasTitle: (title: string) => BrowserCondition;
        const hasTitleContaining: (partialTitle: string) => BrowserCondition;
        const hasTabsNumber: (num: number) => BrowserCondition;
        const hasTabsNumberMoreThan: (num: number) => BrowserCondition;
        const hasTabsNumberLessThan: (num: number) => BrowserCondition;
        const hasJsReturned: (expected: any, script: string | ((document: Document) => any), ...args: any[]) => BrowserCondition;
    }
}
