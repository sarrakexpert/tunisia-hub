"use strict";
// Copyright 2018 Knowledge Expert SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Customized = exports.Configuration = void 0;
// import * as path from 'path';
const selenium_webdriver_1 = require("selenium-webdriver");
const browser_1 = require("./browser");
const extensions_1 = require("./utils/extensions");
class Configuration {
    // TODO: cover other builder.using* properties like proxy and agent
    constructor(_a = {}) {
        var { driver, _driver, _buildDriver: buildDriver } = _a, options = __rest(_a, ["driver", "_driver", "_buildDriver"]);
        this.timeout = 4000; // todo: seems like explicit types are not needed somewhere...
        this.baseUrl = '';
        this.setValueByJs = false;
        this.typeByJs = false;
        this.windowWidth = ''; // todo: why not as number?
        this.windowHeight = ''; // todo: why not as number?
        // readonly htmlPath: string                = path.resolve('./htmls');
        // readonly screenshotPath: string          = path.resolve('./screenshots');
        this.fullPageScreenshot = true;
        // todo: should we bother and make it immutable?
        /*    readonly onFailureHooks: OnEntityFailureHook[] = [
            async (failure: Error, entity: Browser | Element | Collection): Promise<void | Error> => {
                const configuration = (entity as Entity).configuration;
                const driver = configuration.driver;
                const screenshotPath = await saveScreenshot(driver, configuration.screenshotPath);
                const htmlPath = await savePageSource(driver, configuration.htmlPath);
                // todo: handle failure
                return failure;
            }, // todo: how to make it be passed only in entity wait when Entity is Element?
            async (failure: Error, entity: Element): Promise<void | Error> => {
                // ...
            },
            async (failure: Error, entity: Collection): Promise<void | Error> => {
                // ...
            }
        ]; */
        this._locationStrategy = extensions_1.Extensions.cssOrXPathToBy;
        this.__getDriver = undefined; // TODO: deprecate
        // todo: should we add something like isDriverAlive()? by default = this._driver != undefined
        // should we refactor out driver, buildDriver, resetDriver, etc into driverManager? for SRP at least
        this.browserName = 'chrome';
        this.capabilities = undefined;
        this.remoteUrl = undefined;
        Object.assign(this, options);
        // if (driver) {
        //     this._driver = driver;
        // }
        Object.assign(this, { _driver: driver !== null && driver !== void 0 ? driver : _driver });
        this._buildDriver = buildDriver !== null && buildDriver !== void 0 ? buildDriver : function fromConfig(config) {
            var _a;
            const builder = new selenium_webdriver_1.Builder();
            const caps = selenium_webdriver_1.Capabilities[(_a = config.browserName) !== null && _a !== void 0 ? _a : 'chrome']();
            if (config.capabilities) {
                caps.merge(config.capabilities);
            }
            if (config.remoteUrl) {
                builder.usingServer(config.remoteUrl);
            }
            return builder.withCapabilities(caps).build();
        };
        Object.defineProperty(this, 'driver', {
            enumerable: false,
            get() {
                var _a;
                if (this.__getDriver) {
                    return this.__getDriver();
                }
                // TODO: should we also check if driver is not closed (i.e. alive)?
                this._driver = (_a = this._driver) !== null && _a !== void 0 ? _a : this._buildDriver(this);
                return this._driver;
            },
            set(value = undefined) {
                this._driver = value;
            },
        });
        this._resetDriver = driver
            // ? async function justQuitDriverThatWasManuallyPassed()
            ? async () => this.driver.quit()
            // : async function quitAndRemoveStoredInstance() {
            : async () => {
                if (!this._driver) {
                    return;
                }
                await this.driver.getSession().then(_ => this.driver.quit(), error => console.warn('You seem to try to quit a browser that is already not alive:', error));
                this.driver = undefined;
            };
    }
    static with() {
        return Customized.configuration();
    }
    static withDriver(driver) {
        return Configuration.with().driver(driver);
    }
}
exports.Configuration = Configuration;
// todo: rename to Customizing?
/* compare:
 *   Customizing.browser().driver(driver).timeout(1000).build()
 *    Customized.browser().driver(driver).timeout(1000).build()
 */
class Customized {
    // todo: limit customizedType values to Browser | Configuration
    constructor(customizedType) {
        this.customizedType = customizedType;
        this.customizedType = customizedType;
        this.configuration = {};
    }
    static browser() {
        return new Customized(browser_1.Browser);
    }
    static configuration() {
        return new Customized(Configuration);
    }
    build() {
        return new this.customizedType(this.configuration);
    }
    driver(webdriver) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), (typeof webdriver === 'function'
            ? { __getDriver: webdriver } // todo: refactor as ...
            : { driver: webdriver } // todo: refactor as ...
        ));
        return this;
    }
    baseUrl(base) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { baseUrl: base });
        return this;
    }
    timeout(milliseconds) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { timeout: milliseconds });
        return this;
    }
    windowWidth(value) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { windowWidth: value });
        return this;
    }
    windowHeight(value) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { windowHeight: value });
        return this;
    }
    setValueByJs(value) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { setValueByJs: value });
        return this;
    }
    typeByJs(value) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { typeByJs: value });
        return this;
    }
    /*    htmlPath(path: string) {
        this.configuration = {...this.configuration, htmlPath: path};
        return this;
    }

    screenshotPath(path: string) {
        this.configuration = {...this.configuration, screenshotPath: path};
        return this;
    } */
    fullPageScreenshot(turnedOn) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { fullPageScreenshot: turnedOn });
        return this;
    }
    /*    onFailureHooks(hooks: OnEntityFailureHook[]) { // todo: consider switching to varargs
            this.configuration = {...this.configuration, onFailureHooks: hooks};
            return this;
        } */
    _locationStrategy(fn) {
        this.configuration = Object.assign(Object.assign({}, this.configuration), { _locationStrategy: fn });
        return this;
    }
}
exports.Customized = Customized;
//# sourceMappingURL=configuration.js.map